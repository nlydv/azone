#!/usr/bin/env bash
#
# Name:     azone
# Desc:     DNSSEC zone signing and key management bash script.
#           This command-line tool simplifies the use of NSD, an
#           authoritative-only DNS name server, and the various
#           related ldns tools.
#
# Source:   https://github.com/nlydv/azone
# Author:   Neel Yadav
# Date:     09.19.2021

VERSION=0.1.2
COMMAND=$1
ZONE=$2

# These four locations can be customized if needed
ZONEDIR=/etc/nsd/azone
DATADIR=${ZONEDIR}/data
KEYDIR=${ZONEDIR}/keys
NSDCONF=/etc/nsd/nsd.conf

ZONEFILE=${ZONEDIR}/$ZONE
SIGNED=${ZONEDIR}/signed/${ZONE}.signed
DEFZONE=${DATADIR}/zones.conf

KSK=${KEYDIR}/${ZONE}/$(cat ${KEYDIR}/${ZONE}/ksk 2> /dev/null)
ZSK=${KEYDIR}/${ZONE}/$(cat ${KEYDIR}/${ZONE}/zsk 2> /dev/null)

# NSD & ldns-* CLIs used
LDNS_KEYGEN=$(which ldns-keygen)
LDNS_SIGN=$(which ldns-signzone)
LDNS_VERIFY=$(which ldns-verify-zone)
LDNS_KEY2DS=$(which ldns-key2ds)
NSD_CONTROL=$(which nsd-control)

# INIT: error checking process on exec (of non-informational commands)
# ————————————————————————————————————————————————————————————————————

initialize () {
    # || -z $NSD_CONTROL || -z $(which nsd)
    if [[ -z $LDNS_KEYGEN || -z $LDNS_SIGN || -z $LDNS_VERIFY || -z $LDNS_KEY2DS ]]; then
        echo -e "\n  ${red}${bold}✖ ${reset}${bold}Error${reset} — ldns command line tools are either not installed or are not accessible from \$PATH\n"
        exit 13
    elif [[ ! $EUID == 0 ]]; then
        echo -e "\n  ${yellow}${bold}！${reset}sudo permissions required\n"
        exit 13
    fi

    if [[ $ZONEDIR == "/etc/nsd/azone" ]]; then
        [[ ! -d $ZONEDIR ]] && mkdir $ZONEDIR
    else
        echo -e "\n  ${red}${bold}✖ ${reset}${bold}Error${reset} — non-default ZONEDIR directory does not exist — ${ZONEDIR}\n"
        exit 13
    fi

    [[ ! -d $KEYDIR ]] && mkdir $KEYDIR
    [[ ! -d $DATADIR ]] && mkdir $DATADIR
    [[ ! -f $DEFZONE ]] \
        && echo -e "# Additional NSD zone defintions included in nsd.conf\n# This file is auto-generated by azone." > ${DATADIR}/zones.conf

    cd $ZONEDIR || exit 13
    return 0
}

# COMMANDS: functions callable by user
# ————————————————————————————————————

usage () {
    cat <<END

${ul}USAGE${reset}
    ${bold}azone [command] ${it}ZONE${xit}${reset}

${ul}COMMANDS${reset}
    sign     ${it}ZONE${xit}    Creates a signed zonefile for ${it}ZONE${xit}
    keygen   ${it}ZONE${xit}    Generates new ksk and zsk keys for ${it}ZONE${xit}
    view     ${it}ZONE${xit}    View info about ${it}ZONE${xit} and its active DS & DNSKEY records
    test     ${it}ZONE${xit}    Locally validates DNSSEC for signed ${it}ZONE${xit}
       -g                 global validation from the live root trust anchor
                          through the locally signed ${it}ZONE${xit}
    import   ${it}PATH${xit}    Find and import existing DNSSEC keys in the directory
                     located at ${it}PATH${xit}
    update           Tell NSD to make changes live by configuring new zones
                     and reloading & rereading all existing zones
    list             List available zonefiles
       -k                 list the zones for which we have DNSSEC keys
       -s                 list zones currently being served by NSD
    help             Display this help message
       -a                 show additional information
    version          Display version of azone

END
    if [[ $1 == "-a" ]]; then
        cat <<END
${ul}INFORMATION${reset}
By default, the associated plain zone file should also simply be
named "ZONE" rather than the common naming schemes of "ZONE.zone"
or "ZONE.txt" for simplicity's sake and because errors may occur
with domains underneath the .zone or .txt TLDs.

This script can handle auto-incrementing your zones' SOA serial
numbers everytime it gets signed. Just place "SIGNED_ON" (without
the quotes) where the actual serial number would otherwise go in
your plain zone files.

This script DOES NOT (currently) manage or update or create the
actual ${it}plain${xit} zonefiles, only ${it}signed${xit} zonefiles. You should make
those manually (or with some other program).

There's a dynamic cron file at data/azone.cron that auto resigns
live zones every week. Move/symlink to wherever your crons go,
if you have an /etc/cron.d dir it's already symlinked. In any
case, RRSIGs created with azone have a shelf life of 36.5 days.

Plain zonefiles should be placed in ZONEDIR.

ZONEDIR: $ZONEDIR
   ZONE: the fully-qualified domain name of interest (no trailing dot)

END
    fi
}

# KEYGEN
keygen () {
    cd $KEYDIR || exit 13
    [[ ! -d $ZONE ]] && mkdir $ZONE     # If ZONE doesn't already have a sub-directory, make one.
    cd $ZONE || exit 13

    # Check if ZONEFILE for ZONE argument exists and if not, ask if user still wants to gen keys.
    if ! check_zonefile; then
        echo -e "\n${bold}Couldn't find zonefile for ${ZONE}.${reset}\n"
        confirm "  Generate keys anyway?" \
            && echo -e "  Ok, brand new set of keys coming up!" \
            || { echo -e "  ${yellow}${bold}！${reset}Key generation aborted${reset}\n"; exit 12; }
    fi

    # Check if a file named 'ksk' or 'zsk' exists in ZONE's dedicated sub-directory within KEYDIR.
    # These one-line files just contain the filename prefixes of ZONE's active KSK or ZSK. If they
    # already exist, generating a new set of keys will overwrite those files. Allow user to abort.
    check_pointers
    if [[ -f ${KSK}.private || -f ${ZSK}.private ]]; then
        echo -e "\n${bold}Found existing keys for ${ZONE}.${reset}"
        echo -e "Any freshly generated key pairs will be the new"
        echo -e "actively used set for this domain. None of the"
        echo -e "pre-existing keys will be deleted though.\n"
        confirm "Continue generating new key set?" \
            || { echo -e "  ${yellow}${bold}！${reset}Key generation aborted${reset}.\n"; exit 12; }
        mv ksk ksk.old; mv zsk zsk.old; mv ds ds.old           # Archive previously active pointer files
    fi

    printf "\n  Generating keys..."; sleep 1
    # @TODO: is an entropy check before creating DNSSEC keys of this size worth the effort?
    $LDNS_KEYGEN -a ECDSAP256SHA256 -b 2048 -k $ZONE 1> ksk 2> err.tmp     # Store active KSK prefix
    $LDNS_KEYGEN -a ECDSAP256SHA256 -b 1024 $ZONE 1> zsk 2> err.tmp        # Store active ZSK prefix
    mv $(cat ksk).ds ds                                                    # Store DS record for active KSK
    if [[ -z "$(cat err.tmp)" ]]; then
        printf "\r  ${green}${bold}✓${reset} Generating keys... ${bold}done${reset}\n\n"
        rm err.tmp
    else
        printf "\n  ${red}${bold}✖ ${reset}${bold}Error${reset} — something went wrong during key creation\n\n"
        rm err.tmp
        exit 11
    fi

    secure_keys
    exit 0
}

# SIGN
sign () {
    inception=$(date -u "+%Y%m%d%H%M01")
    expiration=19691231235959
    calc_expire

    [[ -d ${ZONEDIR}/signed ]] || mkdir signed
    [[ -d ${KEYDIR}/${ZONE} ]] && check_pointers
    if ! check_zonefile; then
        echo -e "\n  ${red}${bold}✖ ${reset}${bold}Error${reset} — unable to locate zonefile for ${ZONE}\n"
        exit 13
    elif [[ ! -f ${KSK}.private || ! -f ${ZSK}.private ]]; then
        echo -e "\n  ${red}${bold}✖ ${reset}${bold}Error${reset} — unable to locate signing keys for ${ZONE}"
        echo -e "  Try generating a new set of keys: ${bold}azone keygen ${ZONE}${reset}\n"
        exit 13
    elif [[ $(grep --count "SIGNED_ON" $ZONEFILE) == 1 ]]; then
        get_serial
    fi

    $LDNS_SIGN -o $ZONE -f $SIGNED -i $inception -e $expiration - $KSK $ZSK < <(sed s/SIGNED_ON/$serial/ $ZONEFILE)

    if [[ $? == 0 ]]; then
        echo -e "\n  ${green}${bold}✓${reset} ${bold}Signed! ${reset}${serial}\n"
        exit 0
    else
        echo -e "\n  ${red}${bold}✖ ${reset}${bold}Error${reset} — something went wrong while trying to sign ${ZONE}.\n"
        exit 11
    fi
}

# TEST
validate () {
    if [[ -z $1 ]]; then
        echo -e "\n  ${red}${bold}✖ ${reset}${bold}Error${reset} — no zone given to test\n"
        exit 15
    elif [[ -n $2 ]]; then
        if [[ $1 == "-g" || $2 == "-g" ]]; then
            [[ $2 == "-g" ]] && local zone=$1
            [[ $1 == "-g" ]] && local zone=$2
            local signed=${ZONEDIR}/signed/${zone}.signed
            valcmd="$LDNS_VERIFY -V 0 -k ${DATADIR}/icann.root.key -k ${DATADIR}/hns.root.key -S ${signed}"
        else
            echo -e "\n  ${red}${bold}✖ ${reset}${bold}Error${reset} — invalid command option\n"
            exit 15
        fi
    else
        local zone=$1
        local signed=${ZONEDIR}/signed/${zone}.signed
        valcmd="$LDNS_VERIFY -V 0 -k ${KEYDIR}/${zone}/ds -S ${signed}"
    fi

    if [[ ! -f ${signed} ]]; then
        echo -e "\n  ${red}${bold}✖${reset} ${bold}Error${reset} — $(basename ${signed}) not found\n"
        exit 13
    elif $valcmd; then
        echo -e "\n  ${green}${bold}✓ ${reset}Signed zonefile is valid.${reset}\n"
        exit 0
    else
        echo -e "\n  ${yellow}${bold}！${reset}Failed to verify DNSSEC signatures.${reset}\n"
        exit 11
    fi
}

# VIEW
zoneview () {
    # check_pointers
    if ! check_zonefile; then
        if [[ ! -f ${KSK}.private || ! -f ${ZSK}.private ]]; then
            if ! check_pointers; then
                echo -e "\n  ${red}${bold}✖${reset} ${bold}Error${reset} — no knowledge of zone\n"
                exit 11
            fi
        else
            local ZONEFILE="${red}not found${reset}"
            local SIGNED="${red}not found${reset}"
        fi
    elif [[ -f ${SIGNED} ]]; then
        local SIGNED=${SIGNED}
        _soa="$(cat $SIGNED | head -1 | sed -E 's/.* ([0-9]+) [0-9]+ [0-9]+ [0-9]+ [0-9]+$/\1/')"
    else
        local SIGNED="${red}not found${reset}"
        _soa="none"
    fi

    echo -e "\n${bold}${ul}${ZONE}${reset}"
    echo -e "  Zonefile:  ${ZONEFILE}"
    echo -e "  Signed:    ${SIGNED}"
    [[ ! $_soa == "none" ]] && echo -e "  Serial:    ${_soa}"

    if [[ ! -f ${KSK}.private || ! -f ${ZSK}.private ]]; then
        echo -e "  DNSSEC:    ${red}no active signing keys${reset}\n"
    else
        _ds="$(cat ${KEYDIR}/${ZONE}/ds | sed -E -e 's/example\.com\..*DS(.*)/\1/' | grep -o -E "[a-z0-9 ]+")"
        _ksk="$(cat ${KSK}.key | sed -E 's/.*(257 3 13 .*) [;].*/\1/')"
        _zsk="$(cat ${ZSK}.key | sed -E 's/.*(256 3 13 .*) [;].*/\1/')"
        echo -e "  DNSSEC:    ${ZONE}. IN DS ${_ds}"
        echo -e "             ${ZONE}. IN DNSKEY ${_ksk}"
        echo -e "             ${ZONE}. IN DNSKEY ${_zsk}\n"
    fi

    exit 0
}

# LIST
zonelist () {
    case $1 in
        -k)
            echo -e "\n${ul}${bold}Available DNSSEC Keys${reset}"
            ls -1 ${KEYDIR} | sed -E 's/(.+)/  \1/'; echo ""
            exit 0
            ;;
        -s)
            if [[ -x $NSD_CONTROL ]]; then
                echo -e "\n${ul}${bold}Zones Served by NSD${reset}"
                sudo $NSD_CONTROL zonestatus | sed -E -e '/state:/d' -e 's/zone:\t//' -e 's/(.+)/  \1/'; echo ""
            else
                echo -e "\n  ${red}${bold}✖${reset} ${bold}Error${reset} — NSD not installed or nsd-control not accessible in \$PATH\n"
                exit 16
            fi
            exit 0
            ;;
        -*)
            echo -e "\n  ${red}${bold}✖${reset} ${bold}Error${reset} — invalid command option\n"
            exit 15
            ;;
        *)
            echo -e "\n${ul}${bold}Zones Available${reset}"
            ls -p ${ZONEDIR} | grep -v -E "(/|\.md)" | sed -E -e 's/.signed//' -e 's/(.+)/  \1/' | sort -u; echo ""
            exit 0
            ;;
    esac
}

# UPDATE
nsd_update () {
    local zone; local name
    local signed="${ZONEDIR}/signed/*.signed"

    for k in $signed; do
        zone=$(echo $k | sed -E 's/(.*)\.signed/\1/')
        name=$(basename $zone)

        # If not using NSD, allow update cron (sans ` && nsd-control reload` command) but do not proceed further
        if [[ ! -x $NSD_CONTROL ]]; then
            autosign_cron
            echo -e "\n  ${red}${bold}✖${reset} ${bold}Error${reset} — NSD not installed or nsd-control not accessible in \$PATH\n"
            exit 16
        fi

        if ! grep -q "zonefile: ${k}" $DEFZONE; then
            echo -e "\nzone:\n\tname: ${name}\n\tzonefile: ${k}" >> $DEFZONE
        fi

        if ! deconfig_main; then
            echo -e "\n  ${red}${bold}✖${reset} ${bold}Error${reset} — ${name} defined in nsd.conf & couldn't move it to zones.conf\n"
            exit 13
        fi

        ! autosign_cron && abc=1
    done

    # Add the "include:" statement in main nsd.conf if it doesn't exist
    if ! grep -q "include: $DEFZONE" $NSDCONF; then
        echo -e "\ninclude: $DEFZONE" >> $NSDCONF
    fi

    # @TODO: echo error notice + info
    $NSD_CONTROL reconfig 1> /dev/null || exit        # Tell NSD to check nsd.conf for changes to zone definitions.
    $NSD_CONTROL reload 1> /dev/null || exit          # Tell NSD to reread the defined zonefiles, changes to which don't usually get picked up on reconfig.

    [[ $abc == 1 ]] && printf "\n  ${yellow}${bold}！${reset}Unable to symlink data/azone.cron to cron.d"
    echo -e "\n  ${green}${bold}✓${reset} ${bold}Success! ${reset} Zone changes relayed to NSD.\n"

    secure_keys; exit 0
}

# IMPORT
keyimport () {
    import_keydir=$1
    if [[ -z $import_keydir ]]; then
        echo -e "\n  ${red}${bold}✖${reset} ${bold}Error${reset} — you must specify a directory path where existing keys are located"
        exit 15
    elif [[ ! -d $import_keydir ]]; then
        echo -e "\n  ${red}${bold}✖${reset} ${bold}Error${reset} — $import_keydir is not a directory"
        exit 15
    else
        cd ${KEYDIR} || exit 13
        ls ${import_keydir}/K* | sed -E 's/.*K(.+)\.\+.*/\1/' | sort -u > imported
        echo -e "\n${ul}${bold}Imported Domain Keys${reset}"

        local ZONE; local x=1
        while [[ -n $(sed -n ${x}p imported) ]]; do
            ZONE=$(sed -n ${x}p imported)
            echo "  ${ZONE}"

            mkdir $ZONE 2> /dev/null
            cp -p ${import_keydir}/K${ZONE}.* ${ZONE}/.
            ( check_pointers )

            ((x++))
        done

        rm imported; echo ""
    fi

    secure_keys
    exit 0
}

# NEW
newzone () {
    domain=$1;
    if [[ -z $domain ]]; then
        echo "no domain given"
        exit 15
    fi;

    cd ${ZONEDIR} || exit 13

    cp ${DATADIR}/abstract.example $domain;
    sed -i.old -E -e "s/plain\.azone\./${domain}\./" -e "s/plain\.azone\./${domain}\./" $domain;
    rm ${domain}.old
}

# AUXILIARY: functions only called internally by other functions
# ——————————————————————————————————————————————————————————————

get_serial () {
    today=$(date +%Y%m%d)
    count=0
    last=19691231

    if [[ ! -w ${DATADIR}/serial-store ]]; then
        if [[ ! -d ${DATADIR} ]]; then
            mkdir ${DATADIR}
        elif [[ ! -e ${DATADIR}/serial-store ]]; then
            echo 'example.com:0:0' > ${DATADIR}/serial-store
        else
            echo -e "\n  ${red}${bold}✖${reset} ${bold}Error${reset} — unable to write to file '${DATADIR}/serial-store'\n"
            exit 13
        fi
    fi

    count=$(sed -n -E "s/^${ZONE}:([0-9]+):([0-9]+)$/\1/p" ${DATADIR}/serial-store)

    if [[ ! -n $count ]]; then
        echo "${ZONE}:0:0" >> ${DATADIR}/serial-store
        count=1
        last=$today
        update_serial
    else
        eval_serial
    fi
}

eval_serial () {
    last=$(sed -n -E "s/^${ZONE}:([0-9]+):([0-9]+)$/\2/p" ${DATADIR}/serial-store)

    if [[ $last == "$today" && $count -gt 0 ]]; then
        ((count++))
    else
        count=1
        last=$today
    fi

    update_serial
}

update_serial () {
    sed -i.old -E "s/^${ZONE}:([0-9]+):([0-9]*)$/${ZONE}:${count}:${last}/" ${DATADIR}/serial-store
    rm ${DATADIR}/serial-store.old

    if [[ $count -lt 10 && $count -gt 0 ]]; then
        count="0${count}"
    fi

    serial="${last}${count}"
}

check_zonefile () {
    if [[ -z $ZONE ]]; then
        echo -e "  ${red}${bold}✖${reset} ${bold}Error${reset} — a zone argument is required in the form of the domain's FQDN"
        exit 15
    elif [[ ! -f $ZONEFILE ]]; then
        if [[ -f ${ZONEFILE}.zone ]]; then
            echo -e "  ${yellow}${bold}！${reset}${bold}Warning${reset}"
            echo -e "\n${bold}No zonefile named ${it}${ZONE}${xit}, but found ${it}${ZONE}.zone${xit} file.${reset}"
            echo -e "By default, ${ul}azone${reset} assumes the associated zonefile for ZONE is simply named ${it}<FQDN>${xit}"
            echo -e "rather than the common naming schemes of ${it}<FQDN>.zone${xit} or ${it}<FQDN>.txt${xit} for"
            echo -e "the sake of simplicity and because errors may occur for domains underneath the .zone or .txt TLDs.\n"
            confirm "  Would you like to rename zonefile ${ZONE}.zone to ${ZONE} before continuing?" \
                && { mv "${ZONEFILE}.zone" "${ZONEFILE}"; echo -e "  Ok, zonefile renamed."; } \
                || ZONEFILE=${ZONEFILE}.zone
        else
            false
        fi
    else
        true
    fi
}

check_pointers () {
    if [[ -d ${KEYDIR}/${ZONE} ]]; then
        cd ${KEYDIR}/${ZONE} 2> /dev/null || return 1
    else
        return 1
    fi

    # Scan to find all existing .key files and set KSK & ZSK pointers to newest ones
    if cat *.key &> /dev/null; then
        for i in {ksk,zsk}; do
            [[ $i == "ksk" ]] && local type="257"
            [[ $i == "zsk" ]] && local type="256"

            cat *.key | grep -E "DNSKEY\s*${type}" | sed -E "s/.* ([0-9]+) \(${i}\).*/\*\1\*/" > ${i}.1
            ls -1t $(cat ${i}.1) | sed -n -E '/key/p' | sed -n -E 1p | sed -E 's/\.key//' > ${i}
            rm ${i}.1
        done

        local KSK; KSK=$(cat ksk)
        local ZSK; ZSK=$(cat zsk)

        if [[ ! -f ${KSK}.key || ! -f ${ZSK}.key ]]; then
            echo -e "  ${red}${bold}✖ ${reset}${bold}Error${reset} — failed to regenerate KSK/ZSK pointer files"
            return 1
        else
            $LDNS_KEY2DS -n "$(cat ksk).key" | sed -E 's/\t[0-9]+(\tIN\tDS)/\1/' > ds   # Generate DS rr from active KSK
            return 0
        fi
    else
        return 1
    fi
}

# Flattened function for prompting a yes/no interactive confirmation dialog
# ex: $ confirm "Wanna keep going?" && echo "continuing..." || echo "aborted."
confirm() {
    read -e -r -t 60 -p"${1:-Are you sure?} (y/N) — " response
    case "$response" in
        [yY][eE][sS]|[yY])
            return 0
            ;;
        *)
            [[ $? -gt 128 ]] && echo -e "\n  ${yellow}${bold}！${reset}Response timeout (1m)\n" && exit 14
            return 1
            ;;
    esac
}

deconfig_main () {
    if grep -q "name: ${name}" $NSDCONF; then
        if [[ ! -f ${DATADIR}/deconfig-zones ]]; then
            echo -e "# Zone configs removed from main nsd.conf to avoid error" > ${DATADIR}/deconfig-zones
            echo -e "# Backed up here automatically for reference by azone\n"> ${DATADIR}/deconfig-zones
        fi
        echo -e "$(grep -E -C 1 "name: ${name}$" ${NSDCONF})\n" >> ${DATADIR}/deconfig-zones

        local h; local i; local j
        i=$(sed -n -E "/name: ${name}$/=" ${NSDCONF})
        (( h = i - 1 )); (( j = i + 1 ))
        sed -i.backup -e ${i}d -e ${h}d -e ${j}d $NSDCONF || return 1
        rm ${NSDCONF}.backup
    fi

    return 0
}

autosign_cron () {
    if [[ ! -e ${DATADIR}/azone.cron ]]; then
        cat <<END > ${DATADIR}/azone.cron
# /etc/cron.d/azone
#
# Weekly DNSSEC zone re-signing job generated by azone

SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/etc/nsd:/etc/nsd/azone

END
    fi

    if ! grep -q "azone sign -q ${name}" ${DATADIR}/azone.cron; then
        if [[ -x $NSD_CONTROL ]]; then
            echo "$(( $RANDOM % 59 + 1 )) 3 * * 0 root azone sign -q $(basename ${name}) && nsd-control reload &> /dev/null" >> ${DATADIR}/azone.cron
        else
            echo "$(( $RANDOM % 59 + 1 )) 3 * * 0 root azone sign -q $(basename ${name})" >> ${DATADIR}/azone.cron
        fi
    fi

    if [[ -d /etc/cron.d ]]; then
        chown root:root ${DATADIR}/azone.cron
        chmod u=rw,g=r,o=r ${DATADIR}/azone.cron

        if [[ ! -f /etc/cron.d/azone ]]; then
            ln -s ${DATADIR}/azone.cron /etc/cron.d/azone || return 1
        fi
    fi

    return 0
}

secure_keys () {
    chown -R root $KEYDIR           # group has limited read-only perms so it can be whatev
    chmod u=rwx,g=rx,o=rx $KEYDIR

    local files="${KEYDIR}/*"
    for i in $files; do
        if [[ -d $i ]]; then
            chmod u=rwx,g=rx,o-rwx $i           # root & group can enter, peek at specific domain dirs
            chmod u=rw,g=r,o-rwx $i/*           # group can read files in domain dirs...
            chmod u=rw,g-rwx,o-rwx $i/*.private # ... except for private keys
        fi
    done
}

calc_expire () {
    # Attempt time calculation assuming GNU date utility
    if date -u --date=+36days12hours +%Y%m%d%H%M02 &> /dev/null; then
        expiration=$(date -u --date=+36days12hours +%Y%m%d%H%M02)
    # Otherwise try BSD version of date
    elif date -u -j -f "%a %b %d %T %Z %Y" "$(date -u -j -v+36d -v+12H)" "+%Y%m%d%H%M02" &> /dev/null; then
        expiration=$(date -u -j -f "%a %b %d %T %Z %Y" "$(date -u -j -v+36d -v+12H)" "+%Y%m%d%H%M02")
    # Assume the worst
    else
        echo -e "\n  ${red}${bold}✖ ${reset}${bold}Y2K38${reset} — time is but a relative property of existence and an ephemeral illusion of the universe\n"
        exit 16
    fi
}

# Output color/style vars
# ———————————————————————
reset=$(tput sgr0)
bold=$(tput bold)
ul=$(tput smul)
it=$(tput sitm); xit=$(tput ritm)
red=$(tput setaf 1)
green=$(tput setaf 2)
yellow=$(tput setaf 3)

# Directing traffic
# —————————————————

case $COMMAND in
    help | usage | '-h' | '--help' | '--usage' | '')
        usage $2
        exit 0
        ;;
    version)
        echo "azone v$VERSION — September 2021"
        echo "Source: https://github.com/nlydv/azone"
        exit 0
        ;;
    *)
        initialize
        case $COMMAND in
            sign)
                [[ $2 == "-q" ]] && $0 sign $3 &> /dev/null || sign
                ;;
            keygen)
                keygen
                ;;
            view | show | info)
                zoneview
                ;;
            test | validate)
                validate $2 $3
                ;;
            update)
                [[ $2 == "-q" ]] && nsd_update $3 &> /dev/null || nsd_update $2
                ;;
            list | ls)
                zonelist $2
                ;;
            regen) # @DEV
                check_pointers
                ;;
            import)
                keyimport $2
                ;;
            new) # @DEV
                newzone $2
                ;;
            *)
                echo -e "\n  ${red}${bold}✖ ${reset}${bold}Error${reset} — unknown command\n"
                exit 15
                ;;
        esac
        ;;
esac

# Exit codes:
#  0 — Success, no error.
# 11 — Error, general.
# 12 — Abort, by user.
# 13 — Abort, by script.
# 14 — Timeout, user input.
# 15 — Error, user input.
# 16 — Exogenous, requisite implementation failure.
