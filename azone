#!/usr/bin/env bash
#
# Name:     azone
# Desc:     DNSSEC zone signing and key management bash script.
#           This command-line tool simplifies the use of NSD, an
#           authoritative-only DNS name server, and the various
#           related ldns tools.
#
# Source:   https://github.com/nlydv/azone
# Author:   Neel Yadav
# Date:     06.27.2021

VERSION=0.1.1
COMMAND=$1
ZONE=$2

# These four locations can be customized if needed
ZONEDIR=/etc/nsd/azone
DATADIR=${ZONEDIR}/data
KEYDIR=${ZONEDIR}/keys
NSDCONF=/etc/nsd/nsd.conf

ZONEFILE=${ZONEDIR}/$ZONE
SIGNED=${ZONEDIR}/signed/${ZONE}.signed
DEFZONE=${DATADIR}/zones.conf

KSK=${KEYDIR}/${ZONE}/$(cat ${KEYDIR}/${ZONE}/ksk 2> /dev/null)
ZSK=${KEYDIR}/${ZONE}/$(cat ${KEYDIR}/${ZONE}/zsk 2> /dev/null)

# NSD & ldns-* CLIs used
LDNS_KEYGEN=$(which ldns-keygen)
LDNS_SIGN=$(which ldns-signzone)
LDNS_VERIFY=$(which ldns-verify-zone)
LDNS_KEY2DS=$(which ldns-key2ds)
NSD_CONTROL=$(which nsd-control)

# INIT: error checking process on exec (of non-informational commands)
# ————————————————————————————————————————————————————————————————————

initialize () {
    # || -z $NSD_CONTROL || -z $(which nsd)
    if [[ -z $LDNS_KEYGEN || -z $LDNS_SIGN || -z $LDNS_VERIFY || -z $LDNS_KEY2DS ]]; then
        echo -e "\n——${red}Error${reset}: NSD and/or ldns command line tools are either not installed or are not accessible from \$PATH\n"
        exit 13
    elif [[ ! -d /etc/nsd ]]; then
        echo -e "\n——${red}Error${reset}: the directory /etc/nsd does not exist\n"
        exit 13
    elif [[ ! $EUID == 0 ]]; then
        echo -e "\n——${red}Error${reset}: azone should only be used with root permissions\n"
        exit 13
    fi

    if [[ $ZONEDIR == "/etc/nsd/azone" ]]; then
        [[ ! -d $ZONEDIR ]] && mkdir $ZONEDIR
    else
        echo -e "\n——${red}Error${reset}: non-default ZONEDIR directory does not exist — ${ZONEDIR}\n"
        exit 13
    fi

    [[ ! -d $KEYDIR ]] && mkdir $KEYDIR
    [[ ! -d $DATADIR ]] && mkdir $DATADIR
    [[ ! -f $DEFZONE ]] \
        && echo -e "# Additional NSD zone defintions included in nsd.conf\n# This file is auto-generated by azone." > ${DATADIR}/zones.conf

    cd $ZONEDIR || exit 13
    return 0
}

# COMMANDS: functions callable by user
# ————————————————————————————————————

usage () {
    cat <<END
${ul}USAGE${reset}
    ${bold}azone [command] ZONE${reset}

${ul}COMANDS${reset}
    sign     ZONE    Creates a signed zonefile for ZONE at ZONE.signed
    keygen   ZONE    Generates new ksk and zsk keys for ZONE
    view     ZONE    View info about ZONE and its active DS & DNSKEY records
    test     ZONE    Locally validates DNSSEC for signed ZONE using the DS as trust anchor
       -g                 global validation from the live root trust anchor through ZONE
    import   PATH    Find and import existing DNSSEC keys in the directory located at PATH
    update           Tell NSD to configure new zones and reload & reread all existing zones
    list             List all zones
       -k                 list the zones for which we have DNSSEC keys
    help             Display this help message
       -a                 show additional information
    version          Display version of azone

END
    if [[ $1 == "-a" ]]; then
        cat <<END
${ul}INFORMATION${reset}
By default, the associated plain zone file should also simply be
named "ZONE" rather than the common naming schemes of "ZONE.zone"
or "ZONE.txt" for simplicity's sake and because errors may occur
with domains underneath the .zone or .txt TLDs.

This script can handle auto-incrementing your zones' SOA serial
numbers everytime it gets signed. Just place "SIGNED_ON" (without
the quotes) where the actual serial number would otherwise go in
your plain zone files.

This script DOES NOT (currently) manage or update or create the
actual ${it}plain${xit} zonefiles, only ${it}signed${xit} zonefiles. You should make
those manually (or with some other program).

There's a dynamic cron file at data/azone.cron that auto resigns
live zones every week. Move/symlink to wherever your crons go,
if you have an /etc/cron.d dir it's already symlinked. In any
case, RRSIGs created with azone have a shelf life of 36.5 days.

Plain zonefiles should be placed in ZONEDIR.

ZONEDIR: $ZONEDIR
   ZONE: the fully-qualified domain name of interest (no trailing dot)

END
    fi
}

# COMMAND: keygen
keygen () {
    cd $KEYDIR || exit 13
    [[ ! -d $ZONE ]] && mkdir $ZONE     # If ZONE doesn't already have a sub-directory, make one.
    cd $ZONE || exit 13

    # Check if ZONEFILE for ZONE argument exists and if not, ask if user still wants to gen keys.
    if ! check_zonefile; then
        echo -e "\n${bold}Couldn't find zonefile for ${ZONE}.${reset}\n"
        confirm "  Generate keys anyway?" \
            && echo -e "  Ok, brand new set of keys coming up!" \
            || { echo -e "——${yellow}Key generation aborted${reset}\n"; exit 12; }
    fi

    # Check if a file named 'ksk' or 'zsk' exists in ZONE's dedicated sub-directory within KEYDIR.
    # These one-line files just contain the filename prefixes of ZONE's active KSK or ZSK. If they
    # already exist, generating a new set of keys will overwrite those files. Allow user to abort.
    check_pointers
    if [[ -f ${KSK}.private || -f ${ZSK}.private ]]; then
        echo -e "\n${bold}Found existing keys for ${ZONE}.${reset}"
        echo -e "Any freshly generated key pairs will be the new"
        echo -e "actively used keys for this domain. None of the"
        echo -e "pre-existing keys will be deleted though.\n"
        confirm "Continue generating new key set?" \
            && echo -e "  Alright, creating new keys and setting them as active for ${ZONE}!" \
            || { echo -e "——${yellow}Key generation aborted${reset}.\n"; exit 12; }
        mv ksk ksk.old; mv zsk zsk.old; mv ds ds.old           # Archive previously active pointer files
    fi

    echo -e "\nGenerating DNSSEC keys for ${ZONE}..."
    # @TODO: is an entropy check before creating DNSSEC keys of this size worth the effort?
    $LDNS_KEYGEN -a ECDSAP256SHA256 -b 2048 -k $ZONE > ksk     # Store active KSK prefix
    $LDNS_KEYGEN -a ECDSAP256SHA256 -b 1024 $ZONE > zsk        # Store active ZSK prefix
    mv $(cat ksk).ds ds                                        # Store DS record for active KSK
    echo -e "Done.\n"

    secure_keys
    exit 0
}

# COMMAND: sign
sign () {
    incep=$(date -u "+%Y%m%d%H%M00")
    expir=$(date -u --date='+36 days 12 hours' "+%Y%m%d%H%M00")

    [[ -d ${ZONEDIR}/signed ]] || mkdir signed
    [[ -d ${KEYDIR}/${ZONE} ]] && check_pointers
    if ! check_zonefile; then
        echo -e "\n——${red}Error${reset}: unable to locate zonefile for ${ZONE}\n"
        exit 13
    elif [[ ! -f ${KSK}.private || ! -f ${ZSK}.private ]]; then
        echo -e "\n——${red}Error${reset}: unable to locate signing keys for ${ZONE}"
        echo -e "  Try generating a new set of keys: ${bold}azone keygen ${ZONE}${reset}\n"
        exit 13
    elif [[ $(grep --count "SIGNED_ON" $ZONEFILE) == 1 ]]; then
        get_serial
    fi

    $LDNS_SIGN -o $ZONE -f $SIGNED -i $incep -e $expir - $KSK $ZSK < <(sed s/SIGNED_ON/$serial/ $ZONEFILE)

    if [[ $? == 0 ]]; then
        echo -e "\n  ${green}Signed! ${reset}"
        echo -e "  Output: signed/${ZONE}.signed\n"
        exit 0
    else
        echo -e "\n——${red}Error${reset}: something went wrong while trying to sign ${ZONE}.\n"
        exit 11
    fi
}

# COMMAND: test
validate () {
    if [[ -z $1 ]]; then
        echo -e "\n——${red}Error${reset}: no zone given to test\n"
        exit 15
    elif [[ -n $2 ]]; then
        if [[ $1 == "-g" || $2 == "-g" ]]; then
            [[ $2 == "-g" ]] && local zone=$1
            [[ $1 == "-g" ]] && local zone=$2
            local signed=${ZONEDIR}/signed/${zone}.signed
            valcmd="$LDNS_VERIFY -V 0 -k ${DATADIR}/icann.root.key -k ${DATADIR}/hns.root.key -S ${signed}"
        else
            echo -e "\n——${red}Error${reset}: invalid command option\n"
            exit 15
        fi
    else
        local zone=$1
        local signed=${ZONEDIR}/signed/${zone}.signed
        valcmd="$LDNS_VERIFY -V 0 -k ${KEYDIR}/${zone}/ds -S ${signed}"
    fi

    if [[ ! -f ${signed} ]]; then
        echo -e "\n——${red}Error${reset}: $(basename ${signed}) not found\n"
        exit 13
    elif $valcmd; then
        echo -e "\n  ${green}Signed zonefile is valid.${reset}\n"
        exit 0
    else
        echo -e "\n  ${yellow}Failed to verify DNSSEC signatures.${reset}\n"
        exit 11
    fi
}

# COMMAND: view
zoneview () {
    # check_pointers
    if ! check_zonefile; then
        if [[ ! -f ${KSK}.private || ! -f ${ZSK}.private ]]; then
            if ! check_pointers; then
                echo -e "\n——${red}Error${reset}: no knowledge of zone\n"
                exit 11
            fi
        else
            local ZONEFILE="${red}not found${reset}"
            local SIGNED="${red}not found${reset}"
        fi
    elif [[ -f ${SIGNED} ]]; then
        local SIGNED=${SIGNED}
    else
        local SIGNED="${red}not found${reset}"
    fi

    echo -e "\n${bold}${ul}${ZONE}${reset}"
    echo -e "  Zonefile:  ${ZONEFILE}"
    echo -e "  Signed:    ${SIGNED}"

    if [[ ! -f ${KSK}.private || ! -f ${ZSK}.private ]]; then
        echo -e "  DNSSEC:    ${red}no active signing keys${reset}\n"
    else
        echo -e "  DNSSEC:    $(cat ${KEYDIR}/${ZONE}/ds)"
        echo -e "             $(cat ${KSK}.key)"
        echo -e "             $(cat ${ZSK}.key)\n"
    fi

    exit 0
}

# COMMAND: list
zonelist () {
    case $1 in
        -k)
            echo -e "\n${ul}${bold}DNSSEC Key Domains${reset}"
            ls -1 ${KEYDIR} | sed -E 's/(.+)/  \1/'; echo ""
            exit 0
            ;;
        -l)
            sudo $NSD_CONTROL zonestatus | sed -E -e '/state:/d' -e 's/zone:\t//' # @DEV
            exit 0
            ;;
        -*)
            echo -e "——${red}Error${reset}: invalid command option"
            exit 15
            ;;
        *)
            echo -e "\n${ul}${bold}Zones Available${reset}"
            ls -p ${ZONEDIR} | grep -v -E "(/|\.md)" | sed -E -e 's/.signed//' -e 's/(.+)/  \1/' | sort -u; echo ""
            exit 0
            ;;
    esac
}

# COMMAND: update
nsd_update () {
    local zone; local name
    local signed="${ZONEDIR}/signed/*.signed"

    for k in $signed; do
        zone=$(echo $k | sed -E 's/(.*)\.signed/\1/')
        name=$(basename $zone)

        if ! grep -q "zonefile: ${k}" $DEFZONE; then
            echo -e "\nzone:\n\tname: ${name}\n\tzonefile: ${k}" >> $DEFZONE
        fi

        if ! deconfig_main; then
            echo -e "\n——${red}Error${reset}: ${name} defined in nsd.conf & couldn't move it to zones.conf\n"
            exit 13
        fi

        ! autosign_cron && abc=1
    done

    # Add the "include:" statement in main nsd.conf if it doesn't exist
    if ! grep -q "include: $DEFZONE" $NSDCONF; then
        echo -e "\ninclude: $DEFZONE" >> $NSDCONF
    fi

    # @TODO: echo error notice + info
    $NSD_CONTROL reconfig 1> /dev/null || exit      # Tell NSD to check nsd.conf for changes in zone definitions.
    $NSD_CONTROL reload $1 1> /dev/null || exit     # Tell NSD to reread the actual zonefile(s), changes to which won't get
                                                    # picked up unless either told to reload (except when reconfig forces
                                                    # it to check out a newly defined zonefile location).

    [[ $abc == 1 ]] && printf "\n  ${yellow}info${reset} — Unable to symlink data/azone.cron to cron.d"
    echo -e "\n  ${green}Success!${reset} Zone changes relayed to NSD.\n"

    secure_keys; exit 0
}

# COMMAND: import
import () {
    import_keydir=$1
    if [[ -z $import_keydir ]]; then
        echo -e "——${red}Error${reset}: you must specify a directory path where existing keys are located"
        exit 15
    elif [[ ! -d $import_keydir ]]; then
        echo -e "——${red}Error${reset}: $import_keydir is not a directory"
        exit 15
    else
        cd ${KEYDIR} || exit 13
        ls ${import_keydir}/K* | sed -E 's/.*K(.+)\.\+.*/\1/' | sort -u > imported
        echo -e "\n  ${yellow}Imported Domains Keys:${reset}"

        local ZONE; local x=1
        while [[ -n $(sed -n ${x}p imported) ]]; do
            ZONE=$(sed -n ${x}p imported)
            echo "  ${ZONE}"

            mkdir $ZONE 2> /dev/null
            cp -p ${import_keydir}/K${ZONE}.* ${ZONE}/.
            ( check_pointers )

            ((x++))
        done

        rm imported; echo ""
    fi

    secure_keys
    exit 0
}

# AUXILIARY: functions only called internally by other functions
# ——————————————————————————————————————————————————————————————

get_serial () {
    today=$(date +%Y%m%d)
    count=0
    last=19700101

    if [[ ! -w ${DATADIR}/serial-store ]]; then
        if [[ ! -d ${DATADIR} ]]; then
            mkdir ${DATADIR}
        elif [[ ! -e ${DATADIR}/serial-store ]]; then
            echo 'example.com:0:0' > ${DATADIR}/serial-store
        else
            echo "——${red}Error${reset}: unable to write to file '${DATADIR}/serial-store'"
        fi
    fi

    count=$(sed -rn "s/^${ZONE}:([0-9]+):([0-9]+)$/\1/p" ${DATADIR}/serial-store)

    if [[ ! -n $count ]]; then
        echo "${ZONE}:0:0" >> ${DATADIR}/serial-store
        count=1
        last=$today
        update_serial
    else
        eval_serial
    fi
}

eval_serial () {
    last=$(sed -rn "s/^${ZONE}:([0-9]+):([0-9]+)$/\2/p" ${DATADIR}/serial-store)

    if [[ $last == "$today" && $count -gt 0 ]]; then
        ((count++))
    else
        count=1
        last=$today
    fi

    update_serial
}

update_serial () {
    sed -i -r "s/^${ZONE}:([0-9]+):([0-9]*)$/${ZONE}:${count}:${last}/" ${DATADIR}/serial-store

    if [[ $count -lt 10 && $count -gt 0 ]]; then
        count="0${count}"
    fi

    serial="${last}${count}"
}

check_zonefile () {
    if [[ -z $ZONE ]]; then
        echo -e "——${red}Error${reset}: a zone argument is required in the form of the domain's FQDN"
        exit 15
    elif [[ ! -f $ZONEFILE ]]; then
        if [[ -f ${ZONEFILE}.zone ]]; then
            echo -e "\n${bold}No zonefile named ${it}${ZONE}${xit}, but found ${it}${ZONE}.zone${xit} file.${reset}"
            echo -e "azone assumes the associated zonefile for ZONE is simply named ${it}<FQDN>${xit} by default"
            echo -e "rather than the common naming scheme of ${it}<FQDN>.zone${xit} for simplicity's sake and"
            echo -e "because errors may occur for domains underneath the .zone TLD.\n"
            confirm "  Would you like to rename zonefile ${ZONE}.zone to ${ZONE} before continuing?" \
                && { mv "${ZONEFILE}.zone" "${ZONEFILE}"; echo -e "  Ok, zonefile renamed."; } \
                || ZONEFILE=${ZONEFILE}.zone
        else
            false
        fi
    # elif [[ ! -f $ZONEFILE && -f ${ZONEFILE}.zone ]]; then  # If ZONEDIR/example.com doesn't exist but ZONEDIR/example.com.zone does...
    #     ZONEFILE=${ZONEFILE}.zone                           #   slap a '.zone' on the end of ZONEFILE
    # elif [[ ! -f $ZONEFILE ]]; then                         # If above isn't the case, and ZONEDIR/example.com still doesn't exist...
    #     false                                               #   just give up
    else
        true
    fi
}

check_pointers () {
    if [[ -d ${KEYDIR}/${ZONE} ]]; then
        cd ${KEYDIR}/${ZONE} 2> /dev/null || return 1
    else
        return 1
    fi

    # Scan to find all existing .key files and set KSK & ZSK pointers to newest ones
    if cat *.key &> /dev/null; then
        for i in {ksk,zsk}; do
            [[ $i == "ksk" ]] && local type="257"
            [[ $i == "zsk" ]] && local type="256"

            cat *.key | grep -E "DNSKEY\s*${type}" | sed -E "s/.* ([0-9]+) \(${i}\).*/\*\1\*/" > ${i}.1
            ls -1t $(cat ${i}.1) | sed -n -E '/key/p' | sed -n -E 1p | sed -E 's/\.key//' > ${i}
            rm ${i}.1
        done

        local KSK; KSK=$(cat ksk)
        local ZSK; ZSK=$(cat zsk)

        if [[ ! -f ${KSK}.key || ! -f ${ZSK}.key ]]; then
            echo -e "——${red}Error${reset}: failed to regenerate KSK/ZSK pointer files"
            return 1
        else
            $LDNS_KEY2DS -n "$(cat ksk).key" | sed -E 's/\t[0-9]+(\tIN\tDS)/\1/' > ds   # Generate DS rr from active KSK
            return 0
        fi
    else
        return 1
    fi
}

# Flattened function for prompting a yes/no interactive confirmation dialog
# ex: $ confirm "Wanna keep going?" && echo "continuing..." || echo "aborted."
confirm() {
    read -e -r -t 60 -p"${1:-Are you sure?} (y/N) — " response
    case "$response" in
        [yY][eE][sS]|[yY])
            return 0
            ;;
        *)
            [[ $? -gt 128 ]] && echo -e "\n——${yellow}Response timeout (1m)${reset}" && exit 14
            return 1
            ;;
    esac
}

deconfig_main () {
    if grep -q "name: ${name}" $NSDCONF; then
        if [[ ! -f ${DATADIR}/deconfig-zones ]]; then
            echo -e "# Zone configs removed from main nsd.conf to avoid error" > ${DATADIR}/deconfig-zones
            echo -e "# Backed up here automatically for reference by azone\n"> ${DATADIR}/deconfig-zones
        fi
        echo -e "$(grep -E -C 1 "name: ${name}$" ${NSDCONF})\n" >> ${DATADIR}/deconfig-zones

        local h; local i; local j
        i=$(sed -n -E "/name: ${name}$/=" ${NSDCONF})
        (( h = i - 1 )); (( j = i + 1 ))
        sed -i.backup -e ${i}d -e ${h}d -e ${j}d $NSDCONF || return 1
        rm ${NSDCONF}.backup
    fi

    return 0
}

autosign_cron () {
    if ! grep -q "azone sign ${name}" ${DATADIR}/azone.cron; then
        echo "1 3 * * 0 root azone sign $(basename ${name}) && nsd-control reload" >> ${DATADIR}/azone.cron
    fi

    if [[ -d /etc/cron.d ]]; then
        if [[ ! -f /etc/cron.d/azone ]]; then
            ln -s ${DATADIR}/azone.cron /etc/cron.d/azone || return 1
        fi
    fi

    return 0
}

secure_keys () {
    chown -R root $KEYDIR           # group has limited read-only perms so it can be whatev
    chmod u=rwx,g=rx,o=rx $KEYDIR

    local files="${KEYDIR}/*"
    for i in $files; do
        if [[ -d $i ]]; then
            chmod u=rwx,g=rx,o-rwx $i           # root & group can enter, peek at specific domain dirs
            chmod u=rw,g=r,o-rwx $i/*           # group can read files in domain dirs...
            chmod u=rw,g-rwx,o-rwx $i/*.private # ... except for private keys
        fi
    done
}

# Output color/style vars
reset=$(tput sgr0)
bold=$(tput bold)
ul=$(tput smul)
it=$(tput sitm); xit=$(tput ritm)
red=$(tput setaf 1)
green=$(tput setaf 2)
yellow=$(tput setaf 3)

# Directing traffic
# —————————————————

case $COMMAND in
    help | usage | '-h' | '--help' | '--usage' | '')
        usage $2
        exit 0
        ;;
    version)
        echo "azone v$VERSION — June 2021"
        echo "Source: https://github.com/nlydv/azone"
        exit 0
        ;;
    *)
        initialize
        case $COMMAND in
            sign)
                sign
                ;;
            keygen)
                keygen
                ;;
            view | show)
                zoneview
                ;;
            test | validate)
                validate $2 $3
                ;;
            update)
                nsd_update $2
                ;;
            list | ls)
                zonelist $2
                ;;
            regen)
                check_pointers # @DEV
                ;;
            import)
                import $2
                ;;
            *)
                echo "——${red}Error${reset}: unknown command"
                exit 15
                ;;
        esac
        ;;
esac

# Exit codes:
#  0 — Success, no error.
# 11 — Error, general.
# 12 — Abort, by user.
# 13 — Abort, by script.
# 14 — Timeout, user input.
# 15 — Error, user input.
